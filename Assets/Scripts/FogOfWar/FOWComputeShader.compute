// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FOWMapGenerator DEFINE_WITH_VALUE=1337
#pragma enable_d3d11_debug_symbols
//#pragma exclude_renderers d3d11_9x
//#pragma exclude_renderers d3d9

//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"


#include "UnityCG.cginc"


struct FoWData
{
	uint MapID;
    float2 position;
    float range;
    int FactionID;
};

struct FoWDataHeader
{
	uint index;
	uint count;
};

//number of threads in each group
#define GroupSize 64

// groupshared is only allowed on basic types
// 16-32 kb max depending on hardware, so lets pick 16kb as max
// 4096 uints = 4 bytes * 4096 = 16,384 tiles = 16,384 bytes = 16kb
#define FoWMap_Size 4096
groupshared uint _FoWMapCache[FoWMap_Size];

StructuredBuffer<FoWData> _FoWData;
uniform RWTexture2DArray<float4> _FoWMap;

StructuredBuffer<FoWDataHeader> _DataCountPerMap;

CBUFFER_START(Params)
float _GridSize;
float _CellSize;
float _MapSize;



float4 FactionBlueColor;
//int FactionBlueID;
float4 FactionRedColor;
//int FactionRedID;

float4 DefaultColor = float4(0, 0, 0, 0);
CBUFFER_END

const int _DataCount2;



float DistanceSqrt(float2 a, float2 b)
{
    float x = pow(a.x - b.x, 2);
    float y = pow(a.y - b.y, 2);
    return x + y;
}

//its your own responsibility to make sure value is a number from 0 to 255, im not making any checks
void ORByteValue(uint target, uint value, out uint destination[FoWMap_Size])
{
	uint step = target % 4; //uint contains 4 bytes
	uint RealTarget = (target - step) / 4;
	uint data;
	
	switch (step)
	{
		case 0:
			data = value;
			break;
		case 1:
			data = value << 8;
			break;
		case 2:
			data = value << 16;
			break;
		case 3:
			data = value << 24;
			break;
	}

	destination[RealTarget] |= data;
}

float4 RGBAuintToFloat4(in uint data)
{
	float4 destination;
	
	destination.r = data && 0x000000FF;
	destination.g = (data && 0x0000FF00) >> 8;
	destination.b = (data && 0x00FF0000) >> 16;
	destination.a = (data && 0xFF000000) >> 24;

	return destination;
}


uint SetRGBAuint(in float4 color)
{
	uint r, g, b, a;
	
	r = (uint) color.r;
	
	g = (uint) color.g;
	g = g << 8;
	
	b = (uint) color.b;
	b = b << 16;
	
	a = (uint) color.a;
	a = a << 24;
	
	return r | g | b | a;
}

uint SetByteuint(in uint4 data)
{
	uint a, b, c, d;
	
	a = data.x;
	
	b = data.y << 8;
	
	c = data.z << 16;
	
	d = data.w << 24;
	
	return a | b | c | d;
}

//make sure offset is not greater than or equal to size of data type, 4 for uint
uint SetSingleByteuint(in uint value, in uint offset)
{
	return value << (8 * offset);
}

uint GetSingleByte(in uint data, in uint offset)
{
	uint bitOffset = (8 * offset);
	uint mask = 0x000000FF << bitOffset;
	
	return (data & mask) >> bitOffset;
}

void SetBytePackedPixel(in uint x, in uint y, in uint width, in uint value)
{
	uint target = (y * width) + x;
	if (target < FoWMap_Size * 4) //4 bytes per uint
	{
		uint index;
		index = floor((float) target / 4); //4 bytes per uint
		uint offset = target % 4;
		
		uint test = _FoWMapCache[index];
			
		InterlockedOr(_FoWMapCache[index], SetSingleByteuint(value, offset));
	}
}

uint GetBytePackedPixel(in uint x, in uint y, in uint width)
{
	uint target = (y * width) + x;
	if (target < FoWMap_Size * 4) //4 bytes per uint
	{
		uint index;
		index = floor((float) target / 4); //4 bytes per uint
		uint offset = target % 4;
			
		uint data = _FoWMapCache[index];
		return GetSingleByte(data, offset);
	}
	
	return 0;
}

void DrawHorizontalLine(in int a, in int x, in int y, in int width, uniform uint ID)
{
	[loop]
	for (int i = max(a, 0); i < min(x, width); i++)
	{		
		SetBytePackedPixel(i, y, width, _FoWData[ID].FactionID);
	}
}

void DrawLineWrapper(in int a, in int b, in int x, in int y, in int width, uniform uint ID)
{
	DrawHorizontalLine(a - x, a + x, b + y, width, ID);
	if (y != 0)
		DrawHorizontalLine(a - x, a + x, b - y, width, ID);
}


void DrawFullCircle(uniform uint ID, in uint width, in int2 offset)
{
	int radius = round(_FoWData[ID].range / _CellSize);
	int error = -radius;

	int x = radius;
	int y = 0;

    //center of the circle
    //x
	int a = round(_FoWData[ID].position.x / _CellSize) + offset.x;
    //y
	int b = round(_FoWData[ID].position.y / _CellSize) + offset.y;
	
	//[loop]
	while (x >= y)
	{
		int lastY = y;

		error += y;
		y += 1;
		error += y;

		DrawLineWrapper(a, b, x, lastY, width, ID);

		if (error >= 0)
		{
			if (x != lastY)
				DrawLineWrapper(a, b, lastY, x, width, ID);

			error -= x;
			x -= 1;
			error -= x;
		}
	}
}

void InitArray(uint size)
{
	for (uint i = 0; i < size; i++)
	{
		_FoWMapCache[i] = 0;
	}
}

// not using this because it seems to be slower than just letting every thread do the whole array? For some reason? Could be compiler magic
void InitArrayThreaded(uint threadID, uint sizePerThread)
{
	//clear atomic map

	[unroll]
	for (uint k = 0; k < sizePerThread; k++)
	{
		//current pixel index in 1D, based on thread ID
		uint realID = (threadID * sizePerThread) + k;
		if (realID > FoWMap_Size)
			break;
		
		_FoWMapCache[realID] = 0;
	}

	//wait for all units to finish
	GroupMemoryBarrierWithGroupSync();
}


//To understand the difference, a bit of hardware knowledge is required:
//Internally, a GPU works on so-called wave fonts, which are SIMD-style processing units (Like a group of threads, where each thread can have it's own data, but they all have to execute the exact same instruction at the exact same time, allways). 
//The number of Threads per wave font is hardware dependent, but is usual either 32 (NVidia) or 64 (AMD).
//Now, with [numthreads(8,1,1)] you request a shader thread group size of 8 x 1 x 1 = 8 threads, which the hardware is free to distribute among it's wave fonts. 
//So, with 32 threads per wave font, the hardware would schedule one wave font per shader group, with 8 active threads in that wave font (the other 24 threads are "inactive", meaning they do the same work, but are discarding any memory writes). 
//Then, with Dispatch(1, 1, 1), you are dispatching one such shader group, meaning there will be one wave font running on the hardware.
//Would you use [numthreads(1,1,1)] instead, only one thread in a wave font could be active. 
//So, by calling Dispatch(8, 1, 1) on that one, the hardware would require to run 8 shader groups (= 8 wave fonts), each one running just with 1/32 active threads, so while you would get the same _FoWMap, you would waste a lot more computational power.
//So, in general, for optimal performance you want to have shader group sizes that are multiples of 32 (or 64), while trying to call Dispatch with as low numbers as reasonable possible.
//https://stackoverflow.com/questions/63034523/difference-between-calling-numthreads-and-dispatch-in-a-unity-compute-shader

[numthreads(GroupSize, 1, 1)]
void FOWMapGenerator(uint3 id : SV_GroupThreadID, uint3 Group : SV_GroupID)
{
	uint width = _GridSize;
	uint gridSize = _GridSize * _GridSize;
	uint gridsPerRow = _MapSize / _GridSize;

	uint instPerThread; // how many units/pixels that need to be drawn per thread
	uint mapIndex = _DataCountPerMap[Group.x].index; // starting point in Data array
	uint dataCount = _DataCountPerMap[Group.x].count; // number of units to draw on the map
	uint Null;

	//_FoWData.GetDimensions(dataCount, Null);
	
	InitArray(FoWMap_Size);

	
	//draw units on atomic map
	instPerThread = (uint) ceil((float) dataCount / GroupSize);
	[loop]
	for (uint i = 0; i < instPerThread; i++)
	{
		uint realID = mapIndex + ((id.x * instPerThread) + i);
		
		//exit loop if thread has no job
		if (realID > (uint) dataCount)
			break;
		//skip if unit is not visible
		//can probably remove this alltogether
		//if (_FoWData[realID].IsVisible == 0)
		//	continue;
		
		int2 offset;
		offset.x = -(Group.x % gridsPerRow * _GridSize);
		offset.y = -floor((Group.x / gridsPerRow) * _GridSize);
		
		DrawFullCircle(realID, width, offset);
	}
	//wait for all units to finish
	GroupMemoryBarrierWithGroupSync();
	
	
	//read atomic map and write on _FoWMap texture
	instPerThread = (uint) ceil((float) gridSize / GroupSize);
	[loop]
	for (uint j = 0; j < instPerThread; j++)
	{
		//current pixel index in 1D, based on thread ID
		uint realID = (id.x * instPerThread) + j;
		if (realID > gridSize)
			break;
		
		//converting that 1D index to a 2D index
		uint3 position = uint3(realID % width, floor(realID / width), Group.x);
		
		uint data = GetBytePackedPixel(position.x, position.y, width);
		
		if (data != 0)
		{
			_FoWMap[position] = 0;
			if (data & 1)
				_FoWMap[position] += FactionBlueColor;
			if (data & 2)
				_FoWMap[position] += FactionRedColor;
		}
		else
			_FoWMap[position] = (position.x + position.y) % 2 > 0 ? DefaultColor : float4(0, 0, 0, 1); //checker board
	}
	
}
